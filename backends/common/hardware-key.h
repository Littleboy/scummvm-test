#ifndef COMMON_HARDWAREKEY
#define COMMON_HARDWAREKEY

#include "backends/common/user-action.h"

namespace Common {

/**
* Describes an available hardware key 
*/
struct HardwareKey {
	/** unique id used for saving/loading to config */
	int32 id;
	/** Human readable description */
	String description; 
	/** 
	* The KeyState that is generated by the back-end 
	* when this hardware key is pressed.
	*/
	KeyState key;

	UserActionCategory preferredCategory;
	UserActionType preferredType;
	int16 group;

	HardwareKey(KeyState ks = KeyState(), String des = "",
		UserActionCategory cat = kGenericUserActionCategory,
		UserActionType ty = kGenericUserActionType,	int gr = 0) {
			key = ks;
			description = des;
			preferredCategory = cat;
			preferredType = ty;
			group = gr;
	}
};


/**
 * Simple class to encapsulate a device's set of HardwareKeys.
 * Each device should extend this and call addHardwareKey a number of times
 * in its constructor to define the device's available keys.
 */ 
class HardwareKeySet {
public:

	HardwareKeySet() {}
	~HardwareKeySet() {
		List<HardwareKey*>::iterator it;
		for (it = _keys.begin(); it != _keys.end(); it++)
			delete *it;
	}

	void addHardwareKey(HardwareKey *key) {
		checkForKey(key);
		_keys.push_back(key);
	}

	const HardwareKey *findHardwareKey(int32 id) const {
		List<HardwareKey*>::iterator it;
		for (it = _keys.begin(); it != _keys.end(); it++) {
			if ((*it)->id == id)
				return (*it);
		}
		return 0;
	}

	const HardwareKey *findHardwareKey(const KeyState& keystate) const {
		List<HardwareKey*>::iterator it;
		for (it = _keys.begin(); it != _keys.end(); it++) {
			if ((*it)->key == keystate)
				return (*it);
		}
		return 0;
	}


private:

	void checkForKey(HardwareKey *key) {
		List<HardwareKey*>::iterator it;
		for (it = _keys.begin(); it != _keys.end(); it++) {
			if ((*it)->id == key->id)
				error("HardwareKey with id %d already given!", key->id);
			else if ((*it)->key == key->key)
				error("HardwareKey with same KeyState already given!");
		}
	}

	List<HardwareKey*> _keys;
};


} // end of namespace Common

#endif