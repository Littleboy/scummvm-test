#ifndef COMMON_KEYMAP
#define COMMON_KEYMAP

#include "common/array.h"
#include "common/events.h"
#include "common/func.h"
#include "common/hashmap.h"
#include "common/list.h"

namespace Common {


enum UserActionType {
	kGenericUserActionType,

	// common actions
	kDirectionUpUserAction,
	kDirectionDownUserAction,
	kDirectionLeftUserAction,
	kDirectionRightUserAction,
	kLeftClickUserAction,
	kRightClickUserAction,
	kSaveUserAction,
	kMenuUserAction,

	kUserActionTypeMax
};

enum UserActionCategory {
	kGenericUserActionCategory,
	// classes of action - probably need to be slightly more specific than this
	kInGameUserAction,   // effects the actual gameplay
	kSystemUserAction,   //show a menu / change volume / etc

	kUserActionCategoryMax
};

/**
* Describes an available hardware key 
*/
struct HardwareKey {
	/** 
	* The KeyState that is generated by the back-end 
	* when this hardware key is pressed.
	*/
	KeyState key;

	/** Human readable description */
	String description; 

	UserActionCategory preferredCategory;
	UserActionType preferredType;
	int group;

	HardwareKey(KeyState ks = KeyState(), String des = "",
			UserActionCategory cat = kGenericUserActionCategory,
			UserActionType ty = kGenericUserActionType,	int gr = 0) {
		key = ks;
		description = des;
		preferredCategory = cat;
		preferredType = ty;
		group = gr;
	}
};

struct UserAction {
	/** Events to be sent when mapped key is pressed */
	List<Event> events;
	/** Human readable description */
	String description;
	UserActionCategory category;
	UserActionType type;
	int priority;
	int group;
	int flags;

	UserAction(	String des = "", 
				UserActionCategory cat = kGenericUserActionCategory,
				UserActionType ty = kGenericUserActionType,
				int pr = 0, int gr = 0, int fl = 0 ) {
		description = des;
		category = cat;
		type = ty;
		priority = pr;
		group = gr;
		flags = fl;
		_hwKey = 0;
	}

	friend class Keymap;

	HardwareKey *mappedKey() { return _hwKey; }
private:
	/** 
	* Key that is mapped to this UserAction, only KeyMap can set this
	*/
	HardwareKey *_hwKey;
};

/**
 * EqualTo function for KeyState
 */
template<> struct EqualTo<KeyState>
	: public BinaryFunction<KeyState, KeyState, bool> {

	bool operator()(const KeyState &x, const KeyState &y) const { 
		return (x.keycode == y.keycode)
			&& (x.ascii == y.ascii)
			&& (x.flags == y.flags); 
	}
};

/**
 * Hash function for KeyState
 */
template<> struct Hash<KeyState>
	: public UnaryFunction<KeyState, uint> {

	uint operator()(const KeyState &val) const { 
		return (uint)(val.keycode * (val.flags << 1));
	}
};

class Keymap {
public:

	Keymap() {}
	Keymap(const Keymap& km);

	/**
	 * Adds a new UserAction to this Map, 
	 * adding it at the back of the internal array
	 * @param action the UserAction to add
	 */
	void addAction(const UserAction& action);

	/**
	* Maps a HardwareKey to the given UserAction
	* @param action must point to a UserAction in this Keymap
	* @param key pointer to HardwareKey to map
	* @note if action does not point to a UserAction in this Keymap a
	*       fatal error will occur
	*/
	void mapKeyToAction(UserAction *action, HardwareKey *key);

	/**
	 * Maps a HardwareKey to the UserAction at the given index
	 * @param index Index of UserAction in the internal array
	 * @param key pointer to HardwareKey to map
	 */
	void mapKeyToAction(uint index, HardwareKey *key);

	/**
	 * Get a read-only array of all the UserActions contained in this Keymap
	 */
	const Array<UserAction>& getUserActions() { return _actions; }

	/**
	 * Find the UserAction that a key is mapped to
	 * @param key the key that is mapped to the required UserAction
	 * @return a pointer to the UserAction or 0 if no
	 */
	UserAction *getMappedAction(KeyState key);

private:

	void internalMapKey(UserAction *action, HardwareKey *hwKey);

	Array<UserAction> _actions;
	HashMap<KeyState, UserAction*> _keymap; 

};


} // end of namespace Common

#endif